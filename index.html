<!DOCTYPE html>
<html lang="ja">

	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<link
			href="https://fonts.googleapis.com/css2?family=BIZ+UDPGothic&family=Kumar+One&family=Shippori+Antique&display=swap"
			rel="stylesheet">
		<script src="https://cdn.tailwindcss.com"></script>
		<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
		<title>ToolBox</title>
	</head>
	<style scoped>
		[v-cloak] {
			display: none;
		}

		.font-KumarOne {
			font-family: 'Kumar One', cursive;
		}

		.font-Arial {
			font-family: 'Arial';
		}

		input[type="time"]::-webkit-calendar-picker-indicator {
			display: none;
			-webkit-appearance: none;
		}

		input[type="time"]::-moz-clear {
			display: none;
		}

		input[type="time"]::-ms-clear {
			display: none;
		}
	</style>

	<body>
		<div id="app">
			<div class="
				flex flex-col justify-start
				p-5 mb-5 space-y-3
				bg-blue-600" v-cloak>
				<p class="
					w-72 translate-y-3
					text-7xl text-left font-KumarOne
					text-white">{{ currentTime }}</p>
				<p class="
					translate-y-1
					text-4xl font-semibold font-Arial
					text-white">{{ currentDate }}</p>
			</div>
			<div class="p-5 flex justify-center">
				<div class="
					p-4 w-72 space-y-4 border border-slate-400 rounded-xl
					text-center font-Arial
					shadow-lg">
					<p class="text-xl">CountdownTimer</p>
					<input class="text-5xl" type="time" step="1" v-model="cTime">
					<div class="space-x-3">
						<button class="
							py-1 w-20 border border-slate-400 hover:border-slate-950 rounded-md 
							text-center hover:font-bold
							shadow-lg" type="button" v-if="isTimerStopped" @click="startTimer()">START</button>
						<button class="
							py-1 w-20 rounded-md
							text-center text-white
							bg-red-400 hover:bg-red-300 shadow-lg" v-else @click="stopTimer()">STOP</button>
						<button class="
							py-1 w-20 border border-slate-400 hover:border-slate-950 rounded-md
							text-center hover:font-bold
							shadow-lg" @click="resetTimer()">RESET</button>
					</div>
				</div>
			</div>
			<div>
				<div class="
					fixed inset-0 size-full flex items-center justify-center
					font-Arial
					bg-gray-800 bg-opacity-75" v-if="dialog">
					<div class="
						p-6 w-72 space-y-5 border rounded-xl
						text-center
						bg-white">
							<p class="text-4xl">Time is up !</p>
							<button class="
								py-1 w-20 rounded-md
								text-center text-white
								bg-blue-400 hover:bg-blue-300 shadow-lg" @click="dialog = false">CLOSE</button>
					</div>
				</div>
			</div>
			<div class="flex flex-col justify-center items-center pt-5 px-5 pb-10">
				<textarea class="p-2 border border-slate-400 w-96 h-96" v-model="memoContent"></textarea>
			</div>
		</div>
		<script>
			const { createApp, ref, onMounted, onUnmounted, watch } = Vue;

			createApp({
				setup() {
					const currentTime = ref('');
					const timeUpdateId = ref(0);
					const dateUpdateId = ref(0);
					const currentDate = ref('');
					const date = ref((new Date(Date.now() - (new Date()).getTimezoneOffset() * 60000)).toISOString().substr(0, 10));
					const initialTime = ref('00:00:00');
					const cTime = ref('00:00:00');
					const sec = ref(0);
					const timerId = ref(0);
					const isTimerStopped = ref(true);
					const dialog = ref(false);
					const hourInSec = 3600;
					const minInSec = 60;
					const memoContent = ref(localStorage.getItem('memo') ? JSON.parse(localStorage.getItem('memo')) : '');

					function zeroPadding(num, len) {
						let zero = '';
						for (let i = 0; i < len; i++) {
							zero += '0';
						}
						return (zero + num).slice(-len);
					};

					function updatetime() {
						const date = new Date();
						const Hour = date.getHours();
						const Min = zeroPadding(date.getMinutes(), 2);
						const Sec = zeroPadding(date.getSeconds(), 2);
						currentTime.value = `${Hour}:${Min}:${Sec}`;
					};

					function updateDate() {
						const date = new Date();
						const Year = date.getFullYear();
						const Month = zeroPadding(date.getMonth() + 1, 2);
						const getDate = zeroPadding(date.getDate(), 2);
						const dayOfWeek = date.getDay();
						const dayOfWeekStr = ["Sunday", "Monday", "Tuesday", "Wednesday", "thursday", "Friday", "Saturday"];
						currentDate.value = `${Year}/${Month}/${getDate} ${dayOfWeekStr[dayOfWeek]}`;
					};

					function timeToSec(t) {
						const [h, m, s] = t.split(':').map(e => parseInt(e));
						return (h || 0) * hourInSec + (m || 0) * minInSec + (s || 0);
					};

					function secToTime(s) {
						return new Date(s * 1000).toISOString().slice(11, 19);
					};

					function countdownInner() {
						sec.value--;
						cTime.value = secToTime(sec.value);
					};

					function countdown() {
						timerId.value = setInterval(countdownInner, 1000);
					};

					function startTimer() {
						sec.value = timeToSec(cTime.value);
						if (sec.value <= 0) return;
						isTimerStopped.value = false;
						countdown();
					};

					function stopTimer() {
						clearInterval(timerId.value);
						isTimerStopped.value = true;
					};

					function resetTimer() {
						stopTimer();
						cTime.value = initialTime.value;
					};

					function timeAlert() {
						dialog.value = true;
					};

					const saveMemo = () => {
						const parsed = JSON.stringify(memoContent.value);
						localStorage.setItem('memo', parsed);
					};

					onMounted(() => {
						timeUpdateId.value = setInterval(updatetime, 1000);

						updateDate();
						const now = new Date();
						const tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1);
						const timeUntilMidnight = tomorrow - now

						setTimeout(() => {
							updateDate();
							dateUpdateId.value = setInterval(updateDate, 24 * 60 * 60 * 1000);
						}, timeUntilMidnight);
					});

					onUnmounted(() => {
						if (timeUpdateId.value) {
							clearInterval(timeUpdateId.value);
						}
						if (dateUpdateId.value) {
							clearInterval(dateUpdateId.value);
						}
					});

					watch([memoContent, sec], ([newMemoContent, newSec]) => {
						saveMemo();

						if (!isTimerStopped.value && newSec <= 0) {
							timeAlert();
							resetTimer();
						}
					}, { deep: true });

					return {
						currentTime,
						currentDate,
						cTime,
						sec,
						isTimerStopped,
						dialog,
						memoContent,
						startTimer,
						stopTimer,
						resetTimer,
					}
				}
			}).mount('#app')
		</script>
	</body>
</html>